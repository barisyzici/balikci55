deneme.html dosyasi
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Scale the Depths</title>
  <link rel="stylesheet" href="style.css" />

</head>
<body>
  <canvas id="gameCanvas" width="1280" height="720"></canvas>
  <script src="player.js"></script>
  <script src="obstacle.js"></script>
  <script src="game.js"></script>
</body>
</html>

game.js sayfasi
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const waveSprite = new Image();
waveSprite.src = 'assets/wave_sprite.png'; // sprite g√∂rselin yolu

const waveFrameWidth = 128;  // her kare geni≈üliƒüi
const waveFrameHeight = 64;  // her kare y√ºksekliƒüi
const waveFrameCount = 6;    // toplam kare sayƒ±sƒ±
let currentWaveFrame = 0;    // ≈üu anki kare
let waveFrameDelay = 0;      // animasyon yava≈ülatma i√ßin saya√ß
const waveFrameDelayMax = 8; // her 8 frame'de bir kare deƒüi≈ütir


let fishingMode = false;
let frameCount = 0;
let removedObstaclesCount = 0;
let keys = {};
let normalBackgroundOffsetX = 0;
const normalScrollSpeed = 0.3;


const normalBackground = new Image();
normalBackground.src = 'assets/arkaplan.png';

const fishingBackground = new Image();
fishingBackground.src = 'assets/fishing_background.png';

let fishingBackgroundOffsetY = 0; // üÜï animasyon i√ßin offset

let player = new Player();
let obstacles = [];
let obstacleInterval = 90;

class TekneAdam {
  constructor() {
    this.width = 250;
    this.height = 250;
    this.x = canvas.width/2;
    this.y = canvas.height - this.height - 125;
    this.speed = 3;
    this.image = new Image();
    this.image.src = 'assets/tekne_adam.png';
  }

  draw() {
    if (this.image.complete) {
      ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
    } else {
      ctx.fillStyle = 'brown';
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.fillStyle = 'blue';
      ctx.fillRect(this.x + 10, this.y + 10, this.width - 20, this.height - 20);
    }
  }

  update(keys) {
    if (keys['ArrowRight'] && this.x + this.width < canvas.width) this.x += this.speed;
    if (keys['ArrowLeft'] && this.x > 0) this.x -= this.speed;
  }

  isAtLeftEdge() {
    return this.x <= 5;
  }
}

let tekneAdam = new TekneAdam();

document.addEventListener('keydown', (e) => {
  keys[e.key] = true;
});
document.addEventListener('keyup', (e) => {
  keys[e.key] = false;
});

function generateObstacle() {
  const width = 48;
  const x = Math.random() * (canvas.width - width);
  obstacles.push(new Obstacle(x));
}

function checkCollision(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}

function update() {
 if (!fishingMode) {
  tekneAdam.update(keys);

  // üîÅ Sprite animasyon g√ºncellemesi
  waveFrameDelay++;
  if (waveFrameDelay >= waveFrameDelayMax) {
    currentWaveFrame = (currentWaveFrame + 1) % waveFrameCount;
    waveFrameDelay = 0;
  }

  normalBackgroundOffsetX += normalScrollSpeed;
  if (normalBackgroundOffsetX > canvas.width) {
    normalBackgroundOffsetX = 0;
  }

  if ((keys['e'] || keys['E']) && tekneAdam.isAtLeftEdge()) {
    fishingMode = true;
    keys['e'] = false;
    keys['E'] = false;
  }
}

 else {
    player.update(keys);

    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].update();

      if (checkCollision(player, obstacles[i])) {
        obstacles.splice(i, 1);
        removedObstaclesCount++;
      } else if (obstacles[i].y > canvas.height) {
        obstacles.splice(i, 1);
      }
    }

    if (frameCount % obstacleInterval === 0) {
      generateObstacle();
    }

    frameCount++;
    fishingBackgroundOffsetY += 0.5; // üÜï Arka plan kaydƒ±rma

    if (fishingBackgroundOffsetY > fishingBackground.height) {
      fishingBackgroundOffsetY = 0; // Sonsuz d√∂ng√º
    }

    if (keys['q'] || keys['Q']) {
      fishingMode = false;
      keys['q'] = false;
      keys['Q'] = false;
      removedObstaclesCount = 0;
      obstacles = [];
    }
  }
}

function drawScore() {
  ctx.fillStyle = 'white';
  ctx.font = '24px Arial';
  ctx.fillText(Yok edilen balƒ±k: ${removedObstaclesCount}, 10, 30);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

if (!fishingMode) {
  if (normalBackground.complete) {
    const x = -normalBackgroundOffsetX;
    ctx.drawImage(normalBackground, x, 0, canvas.width, canvas.height);
    ctx.drawImage(normalBackground, x + canvas.width, 0, canvas.width, canvas.height);
  } else {
    ctx.fillStyle = '#569cdd';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // üü¶ Dalga sprite'ƒ±nƒ± √ßiz (sprite sheet'in doƒüru karesi)
  if (waveSprite.complete) {
    ctx.drawImage(
      waveSprite,
      currentWaveFrame * waveFrameWidth,  // sprite x ba≈ülangƒ±cƒ±
      0,                                  // sprite y
      waveFrameWidth,
      waveFrameHeight,
      0,                                  // canvas √ºzerinde x
      canvas.height - waveFrameHeight,    // canvas √ºzerinde y
      canvas.width,                       // √∂l√ßeklenmi≈ü geni≈ülik
      waveFrameHeight
    );
  }

  tekneAdam.draw();
  ctx.fillStyle = 'white';
  ctx.font = '20px Arial';
  ctx.fillText('En sola gel ve E tu≈üuna basarak balƒ±k tutma moduna ge√ß', 10, 30);
}

 else {
    if (fishingBackground.complete) {
      const y = -fishingBackgroundOffsetY;
      ctx.drawImage(fishingBackground, 0, y, canvas.width, fishingBackground.height);
      ctx.drawImage(fishingBackground, 0, y + fishingBackground.height, canvas.width, fishingBackground.height);
    } else {
      ctx.fillStyle = '#2b6ca3';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    player.draw();
    obstacles.forEach(o => o.draw(ctx));

    ctx.fillStyle = 'white';
    ctx.font = '20px Arial';
    ctx.fillText('Q tu≈üuna basarak tekne moduna d√∂n', 10, 60);
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

gameLoop();

player.js sayfasi
class Player {
  constructor() {
    this.width = 70;
    this.height = 70;
    this.x = canvas.width / 2 - this.width / 2;
    this.y = canvas.height - this.height - 10;
    this.speed = 4;
    this.image = new Image();
    this.image.src = 'assets/kanca.png'; // Kanca g√∂rselinin yolu
  }

  draw() {
    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
  }

  update(keys) {
    if (keys['ArrowLeft'] && this.x > 0) this.x -= this.speed;
    if (keys['ArrowRight'] && this.x + this.width < canvas.width) this.x += this.speed;
    if (keys['ArrowUp'] && this.y > 0) this.y -= this.speed;
    if (keys['ArrowDown'] && this.y + this.height < canvas.height) this.y += this.speed;
  }
}

tekneadam.js dosyasi
class TekneAdam {
  constructor() {
    this.width = 100;
    this.height = 100;
    this.x = 0;  // ba≈ülangƒ±√ß solda
    this.y = canvas.height - this.height - 20; // dipte konumlandƒ±r
    this.speed = 3;
    this.image = new Image();
    this.image.src = 'assets/tekne_adam.png'; // Tekne+adam g√∂rseli
  }

  draw() {
    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
  }

  update(keys) {
    // Sadece saƒüa ve sola hareket etsin
    if (keys['ArrowRight'] && this.x + this.width < canvas.width) this.x += this.speed;
    if (keys['ArrowLeft'] && this.x > 0) this.x -= this.speed;
  }

  isAtLeftEdge() {
    return this.x <= 5;  // Teknenin en soluna gelmi≈ü mi kontrol√º
  }
}


obstacle.js dosyasi
const obstacleImage = new Image();
obstacleImage.src = 'assets/fish.png';

class Obstacle {
  constructor(x) {
    this.width = 48;
    this.height = 48;
    this.x = x;
    this.y = 0;
    this.speed = 2;
  }

  draw() {
    ctx.drawImage(obstacleImage, this.x, this.y, this.width, this.height);
  }

  update() {
    this.y += this.speed;
  }
}

style.css dosyasi
/* style.css */
body {
    margin: 0;
    overflow: hidden;
    background: linear-gradient(to bottom, #99c1e9, #569cdd);
  }
  
 canvas {
  display: block;
  margin: auto;
  background-color: #569cdd; /* arka plan JS ile √ßizildiƒüi i√ßin sadece renk */
}


bu kodda balik tutma modu arkaplani anismasyonu duzgun calismiyor


ChatGPT said:
Balƒ±k tutma modundaki arka plan animasyonunun d√ºzg√ºn √ßalƒ±≈ümamasƒ±, genellikle ≈üu sorunlardan kaynaklanƒ±r:

‚úÖ Sorunun Muhtemel Nedenleri:
1. G√∂rselin height deƒüeri bilinmeden kaydƒ±rƒ±lƒ±yor
fishingBackground.height ifadesi animasyon ba≈üladƒ±ƒüƒ±nda 0 olabilir. G√∂rsel hen√ºz tam y√ºklenmeden bu deƒüere eri≈ümeye √ßalƒ±≈üƒ±rsan fishingBackgroundOffsetY > fishingBackground.height kontrol√º anlamsƒ±z olur.

2. Animasyon sƒ±fƒ±rlanmƒ±yor veya g√∂r√ºnt√º tam d√∂nm√ºyor
Eƒüer fishingBackgroundOffsetY s√ºrekli artar ama doƒüru zamanda sƒ±fƒ±rlanmazsa, "kayma" g√∂r√ºnmez olur (bo≈üluk olu≈üur).

3. G√∂rselin canvas'a doƒüru ≈üekilde kopyalanmamasƒ±
Arka planƒ± 2 kez √ßiziyorsun ama eƒüer ikinci √ßizim ekranƒ±n dƒ±≈üƒ±na ta≈üƒ±yorsa g√∂r√ºnmeyebilir.

‚úÖ D√ºzg√ºn Kaydƒ±rmalƒ± Balƒ±k Tutma Arka Planƒ± (D√ºzenlenmi≈ü Kod)
A≈üaƒüƒ±daki deƒüi≈üiklikleri yap:

üîÅ update fonksiyonu i√ßindeki fishingBackgroundOffsetY i≈ülemi:
js
Copy
Edit
if (fishingBackground.complete && fishingBackground.naturalHeight > 0) {
  fishingBackgroundOffsetY += 0.5;
  if (fishingBackgroundOffsetY > fishingBackground.height) {
    fishingBackgroundOffsetY = 0;
  }
}
üé® draw fonksiyonu i√ßindeki √ßizim kƒ±smƒ±:
js
Copy
Edit
if (fishingBackground.complete && fishingBackground.naturalHeight > 0) {
  const y = -fishingBackgroundOffsetY;
  ctx.drawImage(fishingBackground, 0, y, canvas.width, fishingBackground.height);
  ctx.drawImage(fishingBackground, 0, y + fishingBackground.height, canvas.width, fishingBackground.height);
}
naturalHeight kontrol√º, g√∂rselin ger√ßekten y√ºklenip y√ºklenmediƒüini garantiler.

Ekstra √ñneri:
G√∂rsel y√ºksekliƒüi sabitse, √∂rneƒüin 720 piksel ise, fishingBackground.height yerine direkt 720 yazmak daha garantili olur:

js
Copy
Edit
if (fishingBackgroundOffsetY > 720) {
  fishingBackgroundOffsetY = 0;
}
üß™ Test Etmek ƒ∞√ßin:
assets/fishing_background.png dosyasƒ±nƒ±n boyutu, canvas'tan (720px) y√ºksek olmalƒ±.

G√∂rselin ger√ßekten y√ºklendiƒüinden emin ol:

js
Copy
Edit
fishingBackground.onload = () => {
  console.log('Balƒ±k tutma arka planƒ± y√ºklendi:', fishingBackground.width, fishingBackground.height);
};
ƒ∞stersen arka planƒ± farklƒ± efektlerle (dalga distort, parallax, opacity vs.) daha da geli≈ütirebilirim. Yardƒ±mcƒ± olayƒ±m mƒ±?






You said:
bana yeni game.js dosyasini yazar misin
ChatGPT said:
Tabii! A≈üaƒüƒ±da, sprite tabanlƒ± dalga animasyonu ve d√ºzg√ºn √ßalƒ±≈üan balƒ±k tutma arka plan kaymasƒ± i√ßeren g√ºncel game.js dosyasƒ±nƒ± bulabilirsin. Kodun tamamƒ± uyumlu ≈üekilde d√ºzenlendi:

‚úÖ game.js (Tamamƒ± G√ºncel):
javascript
Copy
Edit
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// DALGA SPRITE AYARLARI
const waveSprite = new Image();
waveSprite.src = 'assets/wave_sprite.png';

const waveFrameWidth = 128;
const waveFrameHeight = 64;
const waveFrameCount = 6;
let currentWaveFrame = 0;
let waveFrameDelay = 0;
const waveFrameDelayMax = 8;

// MODLAR VE VERƒ∞LER
let fishingMode = false;
let frameCount = 0;
let removedObstaclesCount = 0;
let keys = {};

let normalBackgroundOffsetX = 0;
const normalScrollSpeed = 0.3;

// ARKA PLANLAR
const normalBackground = new Image();
normalBackground.src = 'assets/arkaplan.png';

const fishingBackground = new Image();
fishingBackground.src = 'assets/fishing_background.png';

let fishingBackgroundOffsetY = 0;

// NESNELER
let player = new Player();
let obstacles = [];
let obstacleInterval = 90;
let tekneAdam = new TekneAdam();

// KONTROLLER
document.addEventListener('keydown', (e) => {
  keys[e.key] = true;
});
document.addEventListener('keyup', (e) => {
  keys[e.key] = false;
});

// ENGEL OLU≈ûTURUCU
function generateObstacle() {
  const width = 48;
  const x = Math.random() * (canvas.width - width);
  obstacles.push(new Obstacle(x));
}

// √áARPI≈ûMA
function checkCollision(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}

// G√úNCELLEME
function update() {
  if (!fishingMode) {
    tekneAdam.update(keys);

    // Dalga sprite animasyonu
    waveFrameDelay++;
    if (waveFrameDelay >= waveFrameDelayMax) {
      currentWaveFrame = (currentWaveFrame + 1) % waveFrameCount;
      waveFrameDelay = 0;
    }

    // Normal arka plan kaymasƒ±
    normalBackgroundOffsetX += normalScrollSpeed;
    if (normalBackgroundOffsetX > canvas.width) {
      normalBackgroundOffsetX = 0;
    }

    if ((keys['e'] || keys['E']) && tekneAdam.isAtLeftEdge()) {
      fishingMode = true;
      keys['e'] = false;
      keys['E'] = false;
    }
  } else {
    player.update(keys);

    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].update();

      if (checkCollision(player, obstacles[i])) {
        obstacles.splice(i, 1);
        removedObstaclesCount++;
      } else if (obstacles[i].y > canvas.height) {
        obstacles.splice(i, 1);
      }
    }

    if (frameCount % obstacleInterval === 0) {
      generateObstacle();
    }

    frameCount++;

    // üé£ Arka plan yumu≈üak kaydƒ±rma (g√∂rsel y√ºklendiyse)
    if (fishingBackground.complete && fishingBackground.naturalHeight > 0) {
      fishingBackgroundOffsetY += 0.5;
      if (fishingBackgroundOffsetY > fishingBackground.height) {
        fishingBackgroundOffsetY = 0;
      }
    }

    if (keys['q'] || keys['Q']) {
      fishingMode = false;
      keys['q'] = false;
      keys['Q'] = false;
      removedObstaclesCount = 0;
      obstacles = [];
    }
  }
}

// SKOR YAZISI
function drawScore() {
  ctx.fillStyle = 'white';
  ctx.font = '24px Arial';
  ctx.fillText(`Yok edilen balƒ±k: ${removedObstaclesCount}`, 10, 30);
}

// √áƒ∞Zƒ∞M
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!fishingMode) {
    // Normal arka plan
    if (normalBackground.complete) {
      const x = -normalBackgroundOffsetX;
      ctx.drawImage(normalBackground, x, 0, canvas.width, canvas.height);
      ctx.drawImage(normalBackground, x + canvas.width, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = '#569cdd';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Dalga animasyonu
    if (waveSprite.complete) {
      ctx.drawImage(
        waveSprite,
        currentWaveFrame * waveFrameWidth,
        0,
        waveFrameWidth,
        waveFrameHeight,
        0,
        canvas.height - waveFrameHeight,
        canvas.width,
        waveFrameHeight
      );
    }

    tekneAdam.draw();
    ctx.fillStyle = 'white';
    ctx.font = '20px Arial';
    ctx.fillText('En sola gel ve E tu≈üuna basarak balƒ±k tutma moduna ge√ß', 10, 30);
  } else {
    // Balƒ±k tutma arka planƒ±
    if (fishingBackground.complete && fishingBackground.naturalHeight > 0) {
      const y = -fishingBackgroundOffsetY;
      ctx.drawImage(fishingBackground, 0, y, canvas.width, fishingBackground.height);
      ctx.drawImage(fishingBackground, 0, y + fishingBackground.height, canvas.width, fishingBackground.height);
    } else {
      ctx.fillStyle = '#2b6ca3';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    player.draw();
    obstacles.forEach(o => o.draw(ctx));

    drawScore();
    ctx.fillStyle = 'white';
    ctx.font = '20px Arial';
    ctx.fillText('Q tu≈üuna basarak tekne moduna d√∂n', 10, 60);
  }
}

// ANA OYUN D√ñNG√úS√ú
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

gameLoop();
üß™ Notlar:
wave_sprite.png ‚Üí Sprite dalga dosyanƒ± doƒüru eklemelisin (assets/wave_sprite.png)

fishing_background.png ‚Üí Y√ºksekliƒüi canvas‚Äôtan (720px) b√ºy√ºk veya e≈üit olmalƒ± (√∂rneƒüin 1024px)

G√∂rseller assets/ klas√∂r√ºnde yer almalƒ±.

ƒ∞stersen bir sonraki adƒ±mda:

Parallax efektli derinlik

Balƒ±k t√ºr√ºne g√∂re puanlama

Daha geli≈ümi≈ü sprite animasyonlarƒ±
ekleyebilirim. Hazƒ±r mƒ±sƒ±n?
